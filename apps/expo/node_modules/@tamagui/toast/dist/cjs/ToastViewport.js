var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ToastViewport_exports = {};
__export(ToastViewport_exports, {
  ToastViewport: () => ToastViewport,
  VIEWPORT_DEFAULT_HOTKEY: () => VIEWPORT_DEFAULT_HOTKEY,
  VIEWPORT_PAUSE: () => VIEWPORT_PAUSE,
  VIEWPORT_RESUME: () => VIEWPORT_RESUME
});
module.exports = __toCommonJS(ToastViewport_exports);
var import_animate_presence = require("@tamagui/animate-presence"), import_compose_refs = require("@tamagui/compose-refs"), import_core = require("@tamagui/core"), import_portal = require("@tamagui/portal"), import_stacks = require("@tamagui/stacks"), import_visually_hidden = require("@tamagui/visually-hidden"), React = __toESM(require("react")), import_constants = require("./constants"), import_ToastProvider = require("./ToastProvider"), import_jsx_runtime = require("react/jsx-runtime");
const VIEWPORT_NAME = "ToastViewport", VIEWPORT_DEFAULT_HOTKEY = ["F8"], VIEWPORT_PAUSE = "toast.viewportPause", VIEWPORT_RESUME = "toast.viewportResume", ToastViewportWrapperFrame = (0, import_core.styled)(import_stacks.YStack, {
  name: "ViewportWrapper",
  variants: {
    unstyled: {
      false: {
        pointerEvents: "box-none",
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        position: import_core.isWeb ? "fixed" : "absolute",
        maxWidth: "100%",
        tabIndex: 0,
        zIndex: 1e5
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), ToastViewportFrame = (0, import_core.styled)(import_stacks.YStack, {
  name: VIEWPORT_NAME,
  variants: {
    unstyled: {
      false: {
        pointerEvents: "box-none",
        position: import_core.isWeb ? "fixed" : "absolute",
        maxWidth: "100%"
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), ToastViewport = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      name = "default",
      multipleToasts,
      ...viewportProps
    } = props, context = (0, import_ToastProvider.useToastProviderContext)(__scopeToast), getItems = (0, import_ToastProvider.useCollection)(__scopeToast || import_constants.TOAST_CONTEXT), headFocusProxyRef = React.useRef(null), tailFocusProxyRef = React.useRef(null), wrapperRef = React.useRef(null), ref = React.useRef(null), onViewportChange = React.useCallback(
      (el) => {
        context.viewports[name] !== el && context.onViewportChange(name, el);
      },
      [name, context.viewports]
    ), composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, ref, onViewportChange), hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, ""), hasToasts = context.toastCount > 0;
    React.useEffect(() => {
      if (!import_core.isWeb || context.toastCount === 0)
        return;
      const handleKeyDown = (event) => {
        var _a;
        hotkey.every(
          (key) => event[key] || event.code === key
        ) && ((_a = ref.current) == null || _a.focus());
      };
      return document.addEventListener("keydown", handleKeyDown), () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    }, [hotkey, context.toastCount]), React.useEffect(() => {
      if (!import_core.isWeb || context.toastCount === 0)
        return;
      const wrapper = wrapperRef.current, viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent), context.isClosePausedRef.current = !0;
          }
        }, handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent), context.isClosePausedRef.current = !1;
          }
        }, handleFocusOutResume = (event) => {
          !wrapper.contains(
            event.relatedTarget
          ) && handleResume();
        }, handlePointerLeaveResume = () => {
          wrapper.contains(document.activeElement) || handleResume();
        };
        return wrapper.addEventListener("focusin", handlePause), wrapper.addEventListener("focusout", handleFocusOutResume), wrapper.addEventListener("pointermove", handlePause), wrapper.addEventListener("pointerleave", handlePointerLeaveResume), window.addEventListener("blur", handlePause), window.addEventListener("focus", handleResume), () => {
          wrapper.removeEventListener("focusin", handlePause), wrapper.removeEventListener("focusout", handleFocusOutResume), wrapper.removeEventListener("pointermove", handlePause), wrapper.removeEventListener("pointerleave", handlePointerLeaveResume), window.removeEventListener("blur", handlePause), window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef, context.toastCount]);
    const getSortedTabbableCandidates = React.useCallback(
      ({ tabbingDirection }) => {
        const tabbableCandidates = getItems().map((toastItem) => {
          const toastNode = toastItem.ref.current, toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    return React.useEffect(() => {
      if (!import_core.isWeb || context.toastCount === 0)
        return;
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          var _a, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          if (event.key === "Tab" && !isMetaKey) {
            const focusedElement = document.activeElement, isTabbingBackwards = event.shiftKey;
            if (event.target === viewport && isTabbingBackwards) {
              (_a = headFocusProxyRef.current) == null || _a.focus();
              return;
            }
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection: isTabbingBackwards ? "backwards" : "forwards" }), index = sortedCandidates.findIndex(
              (candidate) => candidate === focusedElement
            );
            focusFirst(sortedCandidates.slice(index + 1)) ? event.preventDefault() : isTabbingBackwards ? (
              // @ts-ignore ali TODO type
              (_b = headFocusProxyRef.current) == null || _b.focus()
            ) : (
              // @ts-ignore ali TODO type
              (_c = tailFocusProxyRef.current) == null || _c.focus()
            );
          }
        };
        return viewport.addEventListener("keydown", handleKeyDown), () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates, context.toastCount]), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      ToastViewportWrapperFrame,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        children: [
          hasToasts && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            FocusProxy,
            {
              __scopeToast,
              viewportName: name,
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ToastProvider.Collection.Slot, { __scopeCollection: __scopeToast || import_constants.TOAST_CONTEXT, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            ToastViewportFrame,
            {
              focusable: context.toastCount > 0,
              ref: composedRefs,
              ...viewportProps,
              children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_portal.PortalHost,
                {
                  render: (children) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_animate_presence.AnimatePresence, { exitBeforeEnter: !multipleToasts, children }),
                  name: name ?? "default"
                }
              )
            }
          ) }),
          hasToasts && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            FocusProxy,
            {
              __scopeToast,
              viewportName: name,
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME;
const FOCUS_PROXY_NAME = "ToastFocusProxy", FocusProxy = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, viewportName, ...proxyProps } = props, viewport = (0, import_ToastProvider.useToastProviderContext)(__scopeToast).viewports[viewportName];
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_visually_hidden.VisuallyHidden,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        position: import_core.isWeb ? "fixed" : "absolute",
        onFocus: (event) => {
          if (!import_core.isWeb)
            return;
          const prevFocusedElement = event.relatedTarget;
          !(viewport != null && viewport.contains(prevFocusedElement)) && onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
function focusFirst(candidates) {
  if (!import_core.isWeb)
    return;
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => candidate === previouslyFocusedElement ? !0 : (candidate.focus(), document.activeElement !== previouslyFocusedElement));
}
function getTabbableCandidates(container) {
  if (!import_core.isWeb)
    return [];
  const containerHtml = container, nodes = [], walker = document.createTreeWalker(containerHtml, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      return node.disabled || node.hidden || isHiddenInput ? NodeFilter.FILTER_SKIP : node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; walker.nextNode(); )
    nodes.push(walker.currentNode);
  return nodes;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ToastViewport,
  VIEWPORT_DEFAULT_HOTKEY,
  VIEWPORT_PAUSE,
  VIEWPORT_RESUME
});
//# sourceMappingURL=ToastViewport.js.map
